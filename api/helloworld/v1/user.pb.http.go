// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v0.0.2

package v1

import (
	context "context"
	gin "github.com/gin-gonic/gin"
	http "net/http"
)

// This imports are custom by go-http.
import (
	restyv2 "github.com/go-resty/resty/v2"
	phttp "github.com/yusank/protoc-gen-go-http/http"
)

// This is a compile-time assertion to ensure that generated files are safe and compilable.
var _ context.Context

const _ = gin.Version

var _ http.Client
var _ phttp.CallOption

const _ = restyv2.Version

// 这里定义 handler interface
type UserHTTPHandler interface {
	Register(context.Context, *RegisterRequest) (*RegisterReply, error)
	Login(context.Context, *LoginRequest) (*LoginReply, error)
}

// RegisterUserHTTPHandler define http router handle by gin.
// 注册路由 handler
func RegisterUserHTTPHandler(g *gin.RouterGroup, srv UserHTTPHandler) {
	g.POST("/register", _User_Register0_HTTP_Handler(srv))
	g.POST("/login", _User_Login0_HTTP_Handler(srv))
}

// 定义 handler
// 遍历之前解析到所有 rpc 方法信息

func _User_Register0_HTTP_Handler(srv UserHTTPHandler) func(c *gin.Context) {
	return func(c *gin.Context) {
		var (
			err error
			in  = new(RegisterRequest)
			out = new(RegisterReply)
			ctx = context.TODO()
		)

		if err = c.ShouldBind(in); err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
			return
		}

		// execute
		out, err = srv.Register(ctx, in)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"err": err.Error()})
			return
		}

		c.JSON(http.StatusOK, out)
	}
}

func _User_Login0_HTTP_Handler(srv UserHTTPHandler) func(c *gin.Context) {
	return func(c *gin.Context) {
		var (
			err error
			in  = new(LoginRequest)
			out = new(LoginReply)
			ctx = context.TODO()
		)

		if err = c.ShouldBind(in); err != nil {
			c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"err": err.Error()})
			return
		}

		// execute
		out, err = srv.Login(ctx, in)
		if err != nil {
			c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"err": err.Error()})
			return
		}

		c.JSON(http.StatusOK, out)
	}
}

// UserHTTPClient defines call UserServer client
type UserHTTPClient interface {
	Register(ctx context.Context, req *RegisterRequest, opts ...phttp.CallOption) (*RegisterReply, error)
	Login(ctx context.Context, req *LoginRequest, opts ...phttp.CallOption) (*LoginReply, error)
}

// UserHTTPClientImpl implement UserHTTPClient
type UserHTTPClientImpl struct {
	cli        *restyv2.Client
	clientOpts []phttp.ClientOption
}

func NewUserHTTPClient(cli *http.Client, opts ...phttp.ClientOption) (UserHTTPClient, error) {
	c := &UserHTTPClientImpl{
		clientOpts: opts,
	}

	hc := cli
	if hc == nil {
		hc = http.DefaultClient
	}

	c.cli = restyv2.NewWithClient(hc)
	for _, opt := range opts {
		if err := opt.Apply(c.cli); err != nil {
			return nil, err
		}
	}

	return c, nil
}

// Register is call [POST] /register api.
func (c *UserHTTPClientImpl) Register(ctx context.Context, req *RegisterRequest, opts ...phttp.CallOption) (rsp *RegisterReply, err error) {
	rsp = new(RegisterReply)

	r := c.cli.R()
	for _, opt := range opts {
		if err = opt.Before(r); err != nil {
			return
		}
	}
	// set response data struct.
	r.SetResult(rsp)
	// do request
	restyResp, err := r.Execute("POST", "/register")
	if err != nil {
		return nil, err
	}
	for _, opt := range opts {
		if err = opt.After(restyResp); err != nil {
			return
		}
	}

	return
}

// Login is call [POST] /login api.
func (c *UserHTTPClientImpl) Login(ctx context.Context, req *LoginRequest, opts ...phttp.CallOption) (rsp *LoginReply, err error) {
	rsp = new(LoginReply)

	r := c.cli.R()
	for _, opt := range opts {
		if err = opt.Before(r); err != nil {
			return
		}
	}
	// set response data struct.
	r.SetResult(rsp)
	// do request
	restyResp, err := r.Execute("POST", "/login")
	if err != nil {
		return nil, err
	}
	for _, opt := range opts {
		if err = opt.After(restyResp); err != nil {
			return
		}
	}

	return
}
